1.自我介绍

2.java1.7和1.8的区别
一 StreamApi--jdk1.8增加了stream特性，主要是基于fork-join框架构建，而且你可以通过parallel()与sequential()在并行流与顺序流之间进行切换。
二 Hashmap性能优化：
 1最重要的一点是底层结构不一样，1.7是数组+链表，1.8则是数组+链表+红黑树结构;
 2.插入键值对的put方法的区别，1.8中会将节点插入到链表尾部，而1.7中是采用头插 
3.jdk1.7中的hash函数对哈希值的计算直接使用key的hashCode值，而1.8中则是采用key的hashCode异或上key的hashCode进行无符号右移16位的结果，避免了只靠低位数据来计算哈希时导致的冲突，计算结果由高低位结合决定，使元素分布更均匀 

3.日志的级别
从高到低依次分为debug info warn error。
info 一般处理业务逻辑的时候使用，就跟 system.err打印一样，用于说明此处是干什么的。slf4j使用的时候是可以动态的传参的，使用占位符 {} 。后边一次加参数，会挨个对应进去。
debug: 一般放于程序的某个关键点的地方，用于打印一个变量值或者一个方法返回的信息之类的信息
error： 用户程序报错，必须解决的时候使用此级别打印日志。
不常用的有：
warn：警告，不会影响程序的运行，但是值得注意。
常用的就是sl4j，log4j，logback

4.如果一个查询功能较慢可以在哪方面入手
（1）代码优化
代码优化分析相关的代码，找出相应的瓶颈，再来考虑具体的优化策略。减少循环次数循环是消耗时间的操作，应该尽可能减少循环次数。使用缓存：缓存可以避免重复计算，提高性能。
（2）数据库层面优化
sql语句的优化加入适合的索引，查询尽量大写，少使用*，使用where代替having，exist代替in，not exist代替not in，多使用commit
（3）数据库表的优化
还可以进行分库分表（水平分，垂直分）


5.支付购物车安全方面的问题
订单方面可以用到分布式锁来解决并发安全问题
支付的话支付宝是用到rsa非对称加密
微信的话支付是进行md5不可逆的加密

6.vue的生命周期
① beforeCreate 在实例初始化之后，数据观测和事件配置之前被调用。
② created 在实例创建完成后被立即调用。
③ beforeMount 在挂载开始之前被调用。
④ mounted el被新创建的vm.$el替换，并挂载到实例上去之后调用该钩子。
⑤ beforeUpdate 数据更新时调用，发生在虚拟DOM打补丁之前。
⑥ updated 由于数据更改导致的虚拟DOM重新渲染和打补丁，在这之后会调用该钩子。
⑦ beforeDestroy 实例销毁之前调用。
⑧ destroyed 实例销毁后调用

7.购物车模块实现（没有登录下，登录下）
未登录时购物车的实现：未登录时，购物车使用cooki存放商品，cookie的key存游客的名字，游客的名字随意起。cookie的value存放商品，value是一个map，map的key是商品id，value是商品数量。
登录后的购物车使用redis存放。redis使用hash结构，hash有三个字段，分别是key，field和value。key是用户id，field和value是cookie中的value，使用redisTemplate中的putAll方法可以直接将map放进去。在把商品放进redis之前需要有两个判断，第一个判断：该用户购物车在没登录时，是否有商品。如果有商品，就把cookie中的商品存进redis中，此时有另一个判断，该用户在登录后是否有购物车。如果没有就创建一个购物车存放。如果有就把新放入的商品增加到购物车。

8.商品的余量怎么同步的（减库存的问题）
直接减，利用行级锁，sql语句的更改

9.登录的方式实现
用户密码用一个md5加密，然后验证通过之后可以用jwt生成一个token，返回给前端用导航守卫进行验证

10.什么情况下不太适合使用索引
不常用的字段，加上索引还要去维护

11.this.$refs.nextTick用法
$nextTick等待dom更新之后执行方法中的函数体，vue异步更新DOM

12.怎么让css只在当前组件使用
如果一个页面中，两个组件定义过相同的类名，那么就修改一个组件中的样式就影响到另一个组件，为了防止出现这种问题，需要给<style>标签中加入 scoped ，变成<style scoped>，它的原理其实就是给节点上加入了 data-v-xxxxx ，即使两个组件定义过相同类名，也会通过 data-v-xxxxx 进行隔离。

13.父子组件传值
父组件使用子组件标签
v-bind：数据
props：{属性名，类型}
props：[属性名]
子传父：
子的一方this.$emit（中间事件，值）中间人
父组件使用子的一方组件@中间事件，自己方所需要获取数据的触发事件

14.怎么获取dom节点
使用$refs属性，需要拿到dom节点中定义ref，然后可以通过this.$refs来拿

15.vue双向绑定底层的实现
vue数据双向绑定是通过数据劫持结合发布者-订阅者模式的方式来实现的。
我们已经知道实现数据的双向绑定，首先要对数据进行劫持监听，所以我们需要设置一个监听器Observer，用来监听所有属性。
如果属性发上变化了，就需要告诉订阅者Watcher看是否需要更新。
因为订阅者是有很多个，所以我们需要有一个消息订阅器Dep来专门收集这些订阅者，然后在监听器Observer和订阅者Watcher之间进行统一管理的。
接着，我们还需要有一个指令解析器Compile，对每个节点元素进行扫描和解析，将相关指令（如v-model，v-on）对应初始化成一个订阅者Watcher，并替换模板数据或者绑定相应的函数，此时当订阅者Watcher接收到相应属性的变化，就会执行对应的更新函数，从而更新视图。


16.vue2和vue3的区别
vue2 的响应式原理是利⽤es5 的⼀个 API ，Object.defineProperty()对数据进⾏劫持结合发布订阅模式的⽅式来实现的。
vue3 中使⽤了 es6 的 proxy API 对数据代理，通过 reactive() 函数给每⼀个对象都包⼀层 Proxy，通过 Proxy 监听属性的变化，从⽽ 实现对数据的监控。

17.前后端web性能优化
前端css加载比较大怎么解决（可以利用cdn），一个组件库我只用了一个组件减少引入体积（安全加载）


